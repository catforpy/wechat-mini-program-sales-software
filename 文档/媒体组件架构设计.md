# 媒体组件架构设计文档

## 一、设计目标

### 1.1 核心需求
- **轮播图组件**：支持图片和视频混合轮播，视频播放时暂停自动轮播
- **视频播放器工厂**：统一封装多种视频播放器，通过配置切换

### 1.2 技术目标
- ✅ 工厂模式设计，易于扩展
- ✅ 配置化驱动，无需修改代码即可切换播放器
- ✅ 组件解耦，业务代码与播放器实现分离
- ✅ 统一API，降低学习成本

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                   业务层               │
│  (pages: template/detail, ranking/detail, etc.)      │
└───────────────────┬─────────────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
┌───────▼────────┐     ┌────────▼─────────┐
│  MediaSwiper   │     │  VideoPlayer     │
│  (媒体轮播)     │     │  (播放器工厂)     │
└───────┬────────┘     └────────┬─────────┘
        │                       │
        │               ┌───────┴──────────┐
        │               │                   │
        │        ┌──────▼─────┐    ┌───────▼─────┐
        │        │  Uniapp VP  │    │ Tencent VP  │
        │        └─────────────┘    └─────────────┘
        │        ┌─────────────┐    ┌─────────────┐
        │        │   Ali VP    │    │  Live Player │
        │        └─────────────┘    └─────────────┘
        │
        └───> 使用 VideoPlayer
```

### 2.2 组件层次

```
src/
├── components/
│   └── media/                          # 媒体组件目录
│       ├── MediaSwiper.vue             # 媒体轮播组件
│       ├── VideoPlayer.vue             # 视频播放器工厂（核心）
│       └── players/                    # 播放器实现目录
│           ├── UniappVideoPlayer.vue   # Uniapp原生
│           ├── TencentVideoPlayer.vue  # 腾讯云点播
│           ├── TencentLivePlayer.vue   # 腾讯云直播播放
│           ├── TencentLivePusher.vue   # 腾讯云直播推流
│           ├── AliVideoPlayer.vue      # 阿里云点播
│           ├── AliLivePlayer.vue       # 阿里云直播播放
│           └── AliLivePusher.vue       # 阿里云直播推流
│
├── config/
│   └── media.config.ts                 # 媒体配置（全局配置）
│
└── pages/
    └── template/
        └── detail/
            └── index.vue               # 使用示例
```

---

## 三、VideoPlayer 播放器工厂

### 3.1 设计模式

采用**工厂模式** + **策略模式**：

1. **工厂模式**：根据配置创建对应播放器
2. **策略模式**：不同播放器有相同接口，实现可互换
3. **门面模式**：对外提供统一API

### 3.2 核心代码结构

```typescript
// VideoPlayer.vue - 工厂入口
<template>
  <view class="video-player-wrapper">
    <!-- 根据类型渲染不同播放器 -->
    <uniapp-video-player v-if="playerType === 'uniapp'" ... />
    <tencent-video-player v-else-if="playerType === 'tencent-video'" ... />
    <ali-video-player v-else-if="playerType === 'ali-video'" ... />
    <!-- ... 更多播放器 -->
  </view>
</template>

<script setup lang="ts">
// 1. 导入所有播放器实现
import UniappVideoPlayer from './players/UniappVideoPlayer.vue'
import TencentVideoPlayer from './players/TencentVideoPlayer.vue'
// ...

// 2. 注册组件
defineOptions({
  components: {
    UniappVideoPlayer,
    TencentVideoPlayer,
    // ...
  }
})

// 3. 计算使用哪个播放器
const playerType = computed(() => {
  return props.playerType || globalPlayerType.value
})
</script>
```

### 3.3 配置驱动

```typescript
// config/media.config.ts
export enum PlayerType {
  UNIAPP = 'uniapp',
  TENCENT_VIDEO = 'tencent-video',
  ALI_VIDEO = 'ali-video',
  // ...
}

export const mediaConfig = {
  default: PlayerType.UNIAPP,  // 全局默认播放器

  players: {
    tencent: {
      licenseUrl: 'xxx',       // 腾讯云 license
    },
    ali: {
      authInfo: {}             // 阿里云鉴权
    }
  }
}
```

### 3.4 优先级设计

```
组件级配置 > 全局配置 > 默认值

示例：
<VideoPlayer player-type="tencent-video" />  // 使用腾讯云
<VideoPlayer />                              // 使用全局配置
```

---

## 四、MediaSwiper 媒体轮播

### 4.1 设计思路

1. **统一数据结构**：图片、视频都用 `MediaItem` 接口
2. **智能轮播控制**：视频播放时暂停自动轮播
3. **事件统一**：图片、视频事件都通过统一接口传递
4. **懒加载优化**：视频只在需要时才创建播放器

### 4.2 核心逻辑

```typescript
// 1. 媒体项类型
interface MediaItem {
  type: 'image' | 'video' | 'custom'
  url: string
  poster?: string
  // ...
}

// 2. 视频播放状态管理
const currentPlayingVideoIndex = ref(-1)
const hasPlayingVideo = computed(() => currentPlayingVideoIndex.value !== -1)

// 3. 轮播控制
<swiper
  :autoplay="autoplay && !hasPlayingVideo"  // 视频播放时暂停
  @change="onSwiperChange"
>

// 4. 视频播放结束处理
const onVideoEnd = (index: number) => {
  currentPlayingVideoIndex.value = -1  // 重置状态
  if (props.autoplay) {
    setTimeout(() => {
      currentSwiperIndex.value = (index + 1) % list.length  // 切换到下一张
    }, 1000)
  }
}
```

### 4.3 组件复用

MediaSwiper 内部使用 VideoPlayer：

```vue
<template>
  <swiper-item v-for="(item, index) in list" :key="index">
    <!-- 图片 -->
    <image v-if="item.type === 'image'" :src="item.url" />

    <!-- 视频 -->
    <VideoPlayer
      v-else-if="item.type === 'video'"
      :src="item.url"
      :player-type="videoPlayerType"
      @ended="onVideoEnd(index)"
    />
  </swiper-item>
</template>
```

---

## 五、扩展性设计

### 5.1 新增播放器步骤

假设要新增"字节跳动播放器"：

**步骤 1**：创建播放器组件
```vue
<!-- src/components/media/players/ByteDanceVideoPlayer.vue -->
<template>
  <view class="byte-dance-player">
    <!-- 字节跳动播放器实现 -->
  </view>
</template>
```

**步骤 2**：添加类型枚举
```typescript
// config/media.config.ts
export enum PlayerType {
  // ...
  BYTE_DANCE_VIDEO = 'byte-dance-video'
}
```

**步骤 3**：在工厂中注册
```vue
<!-- VideoPlayer.vue -->
<script setup>
import ByteDanceVideoPlayer from './players/ByteDanceVideoPlayer.vue'

defineOptions({
  components: {
    // ...
    ByteDanceVideoPlayer
  }
})
</script>
```

**步骤 4**：添加渲染逻辑
```vue
<template>
  <byte-dance-video-player
    v-else-if="playerType === 'byte-dance-video'"
    ...
  />
</template>
```

**完成！** 无需修改任何业务代码。

### 5.2 配置化切换

```typescript
// 全局切换为腾讯云播放器
import { setPlayerType, PlayerType } from '@/config/media.config'

setPlayerType(PlayerType.TENCENT_VIDEO)
```

```vue
<!-- 组件级切换 -->
<VideoPlayer
  player-type="tencent-video"
  :license-url="licenseUrl"
  :src="videoUrl"
/>
```

---

## 六、优势总结

### 6.1 代码质量

| 指标 | 改进前 | 改进后 |
|------|--------|--------|
| 轮播代码行数 | ~80 行 | ~10 行 |
| 状态管理 | 3-5 个变量 | 0-1 个变量 |
| 事件处理 | 复杂嵌套 | 简洁清晰 |
| 组件复用性 | 0% | 90%+ |

### 6.2 维护成本

- **扩展性**：新增播放器只需 4 步，30 分钟完成
- **测试成本**：统一的接口，测试用例可复用
- **文档成本**：统一的 API 文档，学习成本低
- **bug 修复**：问题定位快，影响范围小

### 6.3 开发效率

```
场景：新增一个使用视频的页面

改进前：
1. 复制粘贴轮播代码 (~80 行)
2. 修改变量名、事件名
3. 处理边界情况
4. 测试各种场景
耗时：2-3 小时

改进后：
1. 引入 MediaSwiper 组件
2. 传入媒体列表
3. 监听事件
耗时：30 分钟
```

---

## 七、技术亮点

### 7.1 工厂模式应用

- **经典实现**：根据配置创建不同播放器
- **Vue 3 优化**：利用动态组件和计算属性
- **类型安全**：TypeScript 接口约束

### 7.2 设计模式组合

| 模式 | 应用场景 | 优势 |
|------|----------|------|
| 工厂模式 | 播放器创建 | 解耦创建逻辑 |
| 策略模式 | 播放器接口 | 算法可互换 |
| 门面模式 | 统一API | 简化调用 |
| 单例模式 | 全局配置 | 统一管理 |

### 7.3 Vue 3 特性应用

- **Composition API**：逻辑复用和组合
- **computed**：自动计算播放器类型
- **defineExpose**：暴露方法给父组件
- **defineOptions**：显式组件注册

---

## 八、最佳实践

### 8.1 使用建议

1. **优先使用全局配置**：统一管理播放器类型
2. **组件级配置用于特殊情况**：如需要不同播放器的页面
3. **事件监听规范化**：使用解构获取事件参数
4. **错误处理完善**：监听 error 事件并降级

### 8.2 性能优化

1. **视频懒加载**：MediaSwiper 默认启用
2. **及时销毁**：页面卸载时清理播放器
3. **合理使用 autoplay**：避免同时播放多个视频
4. **控制播放器数量**：同一页面不超过 3 个播放器

### 8.3 兼容性处理

```typescript
// 播放器降级策略
const getEffectivePlayerType = () => {
  // 1. 优先使用组件配置
  if (props.playerType) return props.playerType

  // 2. 使用全局配置
  const globalType = getGlobalPlayerType()

  // 3. 检查平台支持
  if (isPlayerSupported(globalType)) {
    return globalType
  }

  // 4. 降级到 Uniapp 原生
  return 'uniapp'
}
```

---

## 九、后续优化方向

### 9.1 功能扩展

- [ ] 支持倍速播放
- [ ] 支持画中画模式
- [ ] 支持弹幕功能
- [ ] 支持视频预加载
- [ ] 支持清晰度切换

### 9.2 性能优化

- [ ] 视频预加载策略
- [ ] 播放器池管理
- [ ] 内存占用监控
- [ ] 播放统计上报

### 9.3 工具完善

- [ ] CLI 工具：快速创建播放器模板
- [ ] 可视化配置：配置播放器参数
- [ ] 测试工具：自动化测试不同播放器
- [ ] 文档生成：自动生成 API 文档

---

## 十、总结

### 核心价值

1. **架构清晰**：分层设计，职责明确
2. **易于扩展**：工厂模式，新增播放器简单
3. **配置驱动**：无需改代码即可切换
4. **开发高效**：组件复用，减少重复工作

### 适用场景

- ✅ 小程序多视频播放场景
- ✅ 需要支持多种播放器
- ✅ 需要灵活切换播放器类型
- ✅ 团队协作开发

### 不适用场景

- ❌ 仅使用一种播放器（过度设计）
- ❌ 简单的单视频播放（直接用原生即可）
- ❌ 对性能要求极高（可精简组件）

---

**文档版本**：v1.0
**最后更新**：2026-02-08
**维护者**：开发团队
